/*package shellfish contains code for computing the splashback shells of
halos in N-body simulations.*/
package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path"
	"bytes"

	"github.com/phil-mansfield/shellfish/cmd"
	"github.com/phil-mansfield/shellfish/cmd/env"
	"github.com/phil-mansfield/shellfish/version"
	"github.com/phil-mansfield/shellfish/logging"
)

var helpStrings = map[string]string{
	// check mode
	"check": `Type "shellfish help" for basic information on invoking the id tool.

The check tool does some basic sanity checks on the snapshot values read from
disk. The goal of this mode is to rule out the possibility of non-compliant
snapshot formats or I/O bugs in Shellfish.

For a documented example of an check config file, type:

     shellfish help check.config

The check tool takes no input from stdin.`,
// id mode
	"id":    `Type "shellfish help" for basic information on invoking the id tool.

The id tool reads halo catalogs and finds the IDs of halos that correspond to
some user-specified range in either ID or mass space. It will automatically
throw out (R200m-identified) subhalos if asked, and can also return the IDs of
the (R200m-identified) subhalos of every host.

For a documented example of an id config file, type:

     shellfish help id.config

The id tool takes no input from stdin.

The id tool prints the following catalog to stdout:

Column 0 - ID:   The halo's catalog ID.
Column 1 - Snap: Index of the halo's snapshot.

(This can be fed directly to shellfish tree and shellfish coord.)

If ExclusionStrategy = neighbor (i.e. if you want to find subhalos):

Column 0 - ID: The subhalo's catalog ID.
Column 1 - Snap: Index of the halo's snapshot

(This can be fed directly to shellfish tree and shellfish coord.)`,
// tree mode
	"tree":  `Type "shellfish help" for basic information on invoking the tree tool.

The tree tool reads a merger tree catalog and extracts the main progenitor
branch for every input halo. The IDs of every halo along the progenitor
branches of the input halos are then output.

For a documented example of a tree config file, type:

     shellfish help tree.config

The tree tool takes the following input from stdin:

Column 0 - ID:   The halo's catalog ID.
Column 1 - Snap: Index of the halo's snapshot.

(This input can be generated by shellfish id.)

The tree tool prints the following catalog to stdout:

Column 0 - ID:   The halo's catalog ID.
Column 1 - Snap: Index of the halo's snapshot.

For conveinece of automated reading, the trees belonging to different halos
will be separated by a line reading "-1 -1". Other Shellfish modes will ignore
these lines and propagate them forward.

(This output can be fed directly to shellfish coord.)`,
// coord
	"coord": `Type "shellfish help" for basic information on invoking the coord tool.

The coord tool reads a halo catalog and outputs the specified values for every
in its input. By default it will return halo IDs, coordinates, and radii in the
format that is needed by other shellfish tools, but since this is a pretty
convenient way to analyze halo catalogs it can be configured to return other
catalog variables.

For a documented example of a coord config file, type:

     shellfish help coord.config

The coord tool takes the following input from stdin:

Column 0 - ID:   The halo's catalog ID.
Column 1 - Snap: Index of the halo's snapshot.

(This input can be generated by shellfish id or shellfish tree.)

The coord tool prints the following catalog to stdout:

Column 0 - ID:    The halo's catalog ID.
Column 1 - Snap:  Index of the halo's snapshot.
Column 2 - X:     X coordinate of the halo in comoving Mpc/h
Column 3 - Y:     Y coordinate of the halo in comoving Mpc/h
Column 4 - Z:     Z coordinate of the halo in comoving Mpc/h
Column 5 - R200m: The radius of the halo in comoving Mpc/h

(This output can be fed directly to shellfish shell or shellfish prof.)`,
// prof
	"prof": `Type "shellfish help" for basic information on invoking the prof tool.

The prof tool outputs a profile for all the input profiles. Many profile types
are supported, ranging from convetional mean radial density profiles,
substructure-resistant percentile profiles, and various profiles that quantify
geometric aspects of the splashback shell.

For a documented example of a prof config file, type:

     shellfish help prof.config

If constructing a profile that doesn't require information about the
splashback shell, the prof tool takes the following input from stdin:

Column 0 - ID:    The halo's catalog ID.
Column 1 - Snap:  Index of the halo's snapshot.
Column 2 - X:     X coordinate of the halo in comoving Mpc/h
Column 3 - Y:     Y coordinate of the halo in comoving Mpc/h
Column 4 - Z:     Z coordinate of the halo in comoving Mpc/h
Column 5 - R200m: The radius of the halo in comoving Mpc/h

(This input can be generated by shellfish coord.)

If constructing a profile that requires information about the splashback shell,
the prof tool takes the following input from stdin

Column 0 - ID:                The halo's catalog ID.
Column 1 - Snap:              Index of the halo's snapshot.
Column 2 - X:                 X coordinate of the halo in comoving Mpc/h
Column 3 - Y:                 Y coordinate of the halo in comoving Mpc/h
Column 4 - Z:                 Z coordinate of the halo in comoving Mpc/h
Column 5 - R200m:             The radius of the halo in comoving Mpc/h
Column 6 to 6 + 2P^2 - P_ijk: The Penna-Dines coefficients of the splashback
                              shell. These are ordered such that P_ijk occurs
                              at index i + j*P + k*P^k, where P is the order of
                              the function.

(This input can be generated by shellfish shell)

The output of the prof tool depends on the chosen profile type and is specified
in the help string for prof.config.`,
	"shell": `Type "shellfish help" for basic information on invoking the shell tool.

The shell tool calculates the shapes of the splashabck shells around a
collection of halos and outputs this shape as a set of Penna-Dines coefficients.

For a documented example of a shell config file, type:

     shellfish help prof.config

The prof tool takes the following input from stdin:

Column 0 - ID:    The halo's catalog ID.
Column 1 - Snap:  Index of the halo's snapshot.
Column 2 - X:     X coordinate of the halo in comoving Mpc/h
Column 3 - Y:     Y coordinate of the halo in comoving Mpc/h
Column 4 - Z:     Z coordinate of the halo in comoving Mpc/h
Column 5 - R200m: The radius of the halo in comoving Mpc/h

(This input can be generated by shellfish coord.)

The shell tool prints the following catalog to stdout:

Column 0 - ID:                The halo's catalog ID.
Column 1 - Snap:              Index of the halo's snapshot.
Column 2 - X:                 X coordinate of the halo in comoving Mpc/h
Column 3 - Y:                 Y coordinate of the halo in comoving Mpc/h
Column 4 - Z:                 Z coordinate of the halo in comoving Mpc/h
Column 5 - R200m:             The radius of the halo in comoving Mpc/h
Column 6 to 6 + 2P^2 - P_ijk: The Penna-Dines coefficients of the splashback
                              shell. These are ordered such that P_ijk occurs
                              at index i + j*P + k*P^2, where P is the order of
                              the function.

(This output can be fed directly to shellfish prof and shellfish stats.)`,
	"stats": `Type "shellfish help" for basic information on invoking the stats tool.

The prof tool outputs a profile for all the input profiles. Many profile types
are supported, ranging from convetional mean radial density profiles,
substructure-resistant percentile profiles, and various profiles that quantify
geometric aspects of the splashback shell.

For a documented example of a stats config file, type:

     shellfish help stats.config

The stats tool takes the following input from stdin:

Column 0 - ID:                The halo's catalog ID.
Column 1 - Snap:              Index of the halo's snapshot.
Column 2 - X:                 X coordinate of the halo in comoving Mpc/h
Column 3 - Y:                 Y coordinate of the halo in comoving Mpc/h
Column 4 - Z:                 Z coordinate of the halo in comoving Mpc/h
Column 5 - R200m:             The radius of the halo in comoving Mpc/h
Column 6 to 6 + 2P^2 - P_ijk: The Penna-Dines coefficients of the splashback
                              shell. These are ordered such that P_ijk occurs
                              at index i + j*P + k*P^2, where P is the order of
                              the function.

(This input can be generated by shellfish shell.)

The stats tool prints the following catalog to stdout:

Column 0  - ID:      The halo's catalog ID.
Column 1  - Snap:    Index of the halo's snapshot.
Column 2  - R_sp:    The volume-equivalent splashback radius in comoving Mpc/h.
Column 3  - M_sp:    The mass contained within the splashback shell in Msun/h.
Column 4  - V_sp:    The volume of the splashback shell in comoving (Mpc/h)^3.
Column 5  - SA_sp:   The surface area of the splashback shell in comoving
                     (Mpc/h)^2.
Column 6  - a_sp:    The length of the major axis of the splashback shell in
                     comoving Mpc/h.
Column 7  - b_sp:    The length of the intermediate axis of the splashback shell
                     in comoving Mpc/h.
Column 8  - c_sp:    The length of the minor axis of the splashback shell in
                     comoving Mpc/h.
Column 9 to 11 - A: The x, y, and z components of the major axis of the
                    splashback in arbitrary units.
`,

	"config":       new(cmd.GlobalConfig).ExampleConfig(),
	"id.config":    cmd.ModeNames["id"].ExampleConfig(),
	"tree.config":  cmd.ModeNames["tree"].ExampleConfig(),
	"coord.config": cmd.ModeNames["coord"].ExampleConfig(),
	"prof.config":  cmd.ModeNames["prof"].ExampleConfig(),
	"shell.config": cmd.ModeNames["shell"].ExampleConfig(),
	"stats.config": cmd.ModeNames["stats"].ExampleConfig(),
	"check.config": cmd.ModeNames["check"].ExampleConfig(),
}

var modeDescriptions = `The best way to learn how to use shellfish is the tutorial on its github page:
https://github.com/phil-mansfield/shellfish/blob/master/doc/tutorial.md
(You can calso find this tutorial in the doc/ folder of this directory,
although the formatting will be less pretty.)

The different tools in the Shellfish toolchain are:

    shellfish check  [____.check.config] [flags]
    shellfish id     [____.id.config]    [flags]
    shellfish tree   [____.tree.config]  [flags]
    shellfish coord  [____.coord.config] [flags]
    shellfish prof   [____.prof.config]  [flags]
    shellfish shell  [____.shell.config] [flags]
    shellfish stats  [____.stats.config] [flags]

(Arguments in brackets are optional.)

Each tool takes the name of a tool-specific config file. Without them, a
default set of variables will be used. You can also specify config variables
through command line flags of the form

    shellfish id --IDs "0, 1, 2, 3, 4, 5" --IDType "M200m"

If you supply both a config file and flags and the two give different values to
the same variable, the command line value will be used.

For documented example config files, type any of:

    shellfish help [ check.config | id.config | prof.config |shell.config |
                     stats.config | tree.config ]

In addition to any arguments passed at the command line, before calling
Shellfish rountines you will need to specify a "global" config file (it
has the file ending ".config"). Do this by setting the $SHELLFISH_GLOBAL_CONFIG
environment variable. For a documented global config file, type

    shellfish help config

The Shellfish tools expect an input catalog through stdin and will return an
output catalog through standard out. (The only exception is the id tool, which
doesn't take any input thorugh stdin) This means that you will generally invoke
shellfish as a series of piped commands. E.g:

    shellfish id example.id.config | shellfish coord | shellfish shell    

For more information on the input and output that a given tool expects, type
any of:

    shellfish help [ check | id | tree | coord | prof | shell | stats ]`

func main() {
	args := os.Args
	if len(args) <= 1 {
		fmt.Fprintf(
			os.Stderr, "I was not supplied with a mode.\nFor help, type "+
				"'./shellfish help'.\n",
		)
		os.Exit(1)
	}

	switch args[1] {
	case "help":
		switch len(args) - 2 {
		case 0:
			fmt.Println(modeDescriptions)
		case 1:
			text, ok := helpStrings[args[2]]
			if !ok {
				fmt.Printf("I don't recognize the help target '%s'\n", args[2])
			} else {
				fmt.Println(text)
			}
		case 2:
			fmt.Println("The help mode can only take a single argument.")
		}
		os.Exit(0)
		// TODO: Implement the help command.
	case "version":
		fmt.Printf("Shellfish version %s\n", version.SourceVersion)
		os.Exit(0)
	case "hello":
		fmt.Printf("Hello back at you! Installation was successful.\n")
		os.Exit(0)
	}

	mode, ok := cmd.ModeNames[args[1]]
	
	if !ok {
		fmt.Fprintf(
			os.Stderr, "You passed me the mode '%s', which I don't "+
				"recognize.\nFor help, type './shellfish help'\n", args[1],
		)
		fmt.Println("Shellfish terminating.")
		os.Exit(1)
	}

	var stdinData []byte
	switch args[1] {
	case "tree", "coord", "prof", "shell", "stats":
		var err error
		stdinData, err = ioutil.ReadAll(os.Stdin)
		if err != nil {
			fmt.Fprintf(os.Stderr, err.Error())
			fmt.Println("Shellfish terminating.")
			os.Exit(1)
		}

		if len(stdinData) == 0 {
			return
		}

		lineEnd := bytes.IndexByte(stdinData, '\n')
		if lineEnd == -1 { lineEnd = len(stdinData) }

		 if lineEnd >= 9 && string(stdinData[:9]) == "Shellfish" {
			fmt.Println(string(stdinData)[:lineEnd])
			os.Exit(1)
		}
	}
	
	flags := getFlags(args[2:])
	config, ok := getConfig(args[2:])
	gConfigName, gConfig, err := getGlobalConfig(args[:2])
	if err != nil {
		log.Printf("Error running mode %s:\n%s\n", args[1], err.Error())
		fmt.Println("Shellfish terminating.")
		os.Exit(1)
	}
	
	if ok {
		if err = mode.ReadConfig(config, flags); err != nil {
			log.Printf("Error running mode %s:\n%s\n", args[1], err.Error())
			fmt.Println("Shellfish terminating.")
			os.Exit(1)
		}
	} else {
		if err = mode.ReadConfig("", flags); err != nil {
			log.Printf("Error running mode %s:\n%s\n", args[1], err.Error())
			fmt.Println("Shellfish terminating.")
			os.Exit(1)
		}
	}

	if err = checkMemoDir(gConfig.MemoDir, gConfigName); err != nil {
		log.Printf("Error running mode %s:\n%s\n", args[1], err.Error())
		fmt.Println("Shellfish terminating.")
		os.Exit(1)
	}
	
	e := &env.Environment{MemoDir: gConfig.MemoDir}
	err = initCatalogs(gConfig, e)
	if err != nil {
		log.Printf("Error running mode %s:\n%s\n", args[1], err.Error())
		fmt.Println("Shellfish terminating.")
		os.Exit(1)
	}
	
	err = initHalos(args[1], gConfig, e)
	if err != nil {
		log.Printf("Error running mode %s:\n%s\n", args[1], err.Error())
		fmt.Println("Shellfish terminating.")
		os.Exit(1)
	}

	switch gConfig.Logging {
	case "nil":
		logging.Mode = logging.Nil
	case "performance":
		logging.Mode = logging.Performance
	case "debug":
		logging.Mode = logging.Debug
	default:
		log.Printf("Unrecognized logging mode, %s", gConfig.Logging)
		os.Exit(1)
	}
	
	out, err := mode.Run(gConfig, e, stdinData)
	if err != nil {
		log.Printf("Error running mode %s:\n%s\n", args[1], err.Error())
		fmt.Println("Shellfish terminating.")
		os.Exit(1)
	}

	for i := range out {
		fmt.Println(out[i])
	}
}

// getFlags reutrns the flag tokens from the command line arguments.
func getFlags(args []string) []string {
	if len(args) == 0 || len(args[0]) == 0 || args[0][0] == '-' {
		return args
	} else {
		return args[1:]
	}
}

// getGlobalConfig returns the name of the base config file from the command
// line arguments.
func getGlobalConfig(args []string) (string, *cmd.GlobalConfig, error) {
	name := os.Getenv("SHELLFISH_GLOBAL_CONFIG")
	if name == "" {
		return "", nil, fmt.Errorf("$SHELLFISH_GLOBAL_CONFIG has not been set.")
	}
	
	config := &cmd.GlobalConfig{}
	err := config.ReadConfig(name, []string{})
	if err != nil {
		return "", nil, err
	}

	return name, config, nil
}

// getConfig return the name of the mode-specific config file from the command
// line arguments.
func getConfig(args []string) (string, bool) {
	if len(args) == 0 || len(args[0]) == 0 || args[0][0] == '-' {
		return "", false
	} 
	return args[0], true
}

// cehckMemoDir checks whether the given MemoDir corresponds to a GlobalConfig
// file with the exact same variables. If not, a non-nil error is returned.
// If the MemoDir does not have an associated GlobalConfig file, the current
// one will be copied in.
func checkMemoDir(memoDir, configFile string) error {
	memoConfigFile := path.Join(memoDir, "memo.config")

	if _, err := os.Stat(memoConfigFile); err != nil {
		// File doesn't exist, directory is clean.
		err = copyFile(memoConfigFile, configFile)
		return err
	}

	config, memoConfig := &cmd.GlobalConfig{}, &cmd.GlobalConfig{}
	if err := config.ReadConfig(configFile, []string{}); err != nil {
		return err
	}
	if err := memoConfig.ReadConfig(memoConfigFile, []string{}); err != nil {
		return err
	}

	if !configEqual(config, memoConfig) {
		return fmt.Errorf(`You've changed the variables in the config file %s in a way that would invlalidate the files Shellfish cached in %s (i.e. MemoDir) to speed up performance. Maybe you wanted this (e.g. there was a mistake in the old config file), but maybe you didn't.

If you wanted to make the change and you're SURE there's nothing that you care about in MemoDir, type the command
    $ rm -r %s/*
and rerun shellfish. (Shellfish could do this for you automatically, but I don't want to accidentally delete something you care about.)

If you want to check what the change is, or if you lost the old config file and want it back, you can find a copy in %s

If you accidentally wrote down the wrong path in the MemoDir variable in %s, you should change it.
` , configFile, memoDir, memoDir, memoConfigFile, configFile)
	}
	return nil
}

// copyFile copies a file from src to dst.
func copyFile(dst, src string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	if _, err = io.Copy(dstFile, srcFile); err != nil {
		return err
	}
	return dstFile.Sync()
}

func configEqual(m, c *cmd.GlobalConfig) bool {
	// Well, equal up to the variables that actually matter.
	// (i.e. changing something like Threads shouldn't flush the memoization
	// buffer. Otherwise, I'd just use reflection.)
	return c.Version == m.Version &&
		c.SnapshotFormat == m.SnapshotFormat &&
		c.SnapshotType == m.SnapshotType &&
		c.HaloDir == m.HaloDir &&
		c.HaloType == m.HaloType &&
		c.TreeDir == m.TreeDir &&
		int64sEqual(c.BlockMins, m.BlockMins) &&
		int64sEqual(c.BlockMaxes, m.BlockMaxes) &&
		c.SnapMin == m.SnapMin &&
		c.SnapMax == m.SnapMax &&
		stringsEqual(c.SnapshotFormatMeanings, m.SnapshotFormatMeanings) &&
		stringsEqual(c.HaloValueNames, m.HaloValueNames) &&
		int64sEqual(c.HaloValueColumns, m.HaloValueColumns) &&
		c.HaloPositionUnits == m.HaloPositionUnits &&
		c.HaloMassUnits == m.HaloMassUnits &&
		int64sEqual(c.HaloValueColumns, m.HaloValueColumns) &&
		stringsEqual(c.HaloValueNames, m.HaloValueNames) &&
		c.Endianness == m.Endianness
}

func int64sEqual(xs, ys []int64) bool {
	if len(xs) != len(ys) {
		return false
	}
	for i := range xs {
		if xs[i] != ys[i] {
			return false
		}
	}
	return true
}

func stringsEqual(xs, ys []string) bool {
	if len(xs) != len(ys) {
		return false
	}
	for i := range xs {
		if xs[i] != ys[i] {
			return false
		}
	}
	return true
}

func initHalos(
	mode string, gConfig *cmd.GlobalConfig, e *env.Environment,
) error {
	switch mode {
	case "shell", "stats", "prof", "check":
		return nil
	}

	switch gConfig.HaloType {
	case "nil":
		return fmt.Errorf("You may not use nil as a HaloType for the "+
			"mode '%s.'\n", mode)
	case "Text":
		return e.InitTextHalo(&gConfig.HaloInfo)
		if gConfig.TreeType != "consistent-trees" {
			return fmt.Errorf("You're trying to use the '%s' TreeType with " +
				"the 'Text' HaloType.")
		}
	}
	if gConfig.TreeType == "nil" {
		return fmt.Errorf("You may not use nil as a TreeType for the "+
			"mode '%s.'\n", mode)
	}

	panic("Impossible")
}

func initCatalogs(gConfig *cmd.GlobalConfig, e *env.Environment) error {
	switch gConfig.SnapshotType {
	case "gotetra":
		return e.InitGotetra(&gConfig.ParticleInfo, gConfig.ValidateFormats)
	case "LGadget-2":
		return e.InitLGadget2(&gConfig.ParticleInfo, gConfig.ValidateFormats)
	case "Gadget-2":
		return e.InitGadget2(&gConfig.ParticleInfo, gConfig.ValidateFormats)
	case "ARTIO":
		return e.InitARTIO(&gConfig.ParticleInfo, gConfig.ValidateFormats)
	case "Bolshoi":
		return e.InitBolshoi(&gConfig.ParticleInfo, gConfig.ValidateFormats)
	}
	panic("Impossible.")
}
